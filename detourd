#!/usr/bin/env python
# -*- coding: utf-8 -*-

import asyncore, asynchat
import os, socket, string
import json

from optparse import OptionParser
import ConfigParser

import hostfile

parser = OptionParser(
	usage="usage: %prog [options]",
	version="%prog 0.1"
)

parser.add_option(
	"-d", "--daemonize",
	action="store_true",
	dest="daemon",
	default=False,
	help="daemonize the process"
)

parser.add_option(
	"-c", "--config",
	action="store",
	dest="config",
	default="/etc/detours.conf",
	help="Config File"
)

(options, args) = parser.parse_args()

if not os.path.isfile( options.config ):
	parser.error( '%s is not a valid configuration file' % options.config )

config = ConfigParser.SafeConfigParser( { 'port': 8551 } )
config.read( options.config )

class DetourChannel ( asynchat.async_chat ):

	def __init__( self, server, sock, addr, hf ):
		asynchat.async_chat.__init__(self, sock)
		self.set_terminator( "\n" )
		self.request = None
		self.data = ""
		self.shutdown = 0
		self.hostfile = hf

	def collect_incoming_data( self, data ):
		self.data = self.data + data

	def found_terminator( self ):
		if not self.request:
			# Select what needs to be done.
			request = json.loads( self.data )
			response = {}
			if request['method'] == 'ping':
				response['response'] = 'pong'
			elif request['method'] == 'list':
				response['response'] = 'list'
				response['pairs'] = self.hostfile.getDetours()
			elif request['method'] == 'set':
				pairs = self.hostfile.getDetours()
				keep = []
				for pair in pairs:
					for newpair in request['pairs']:
						if newpair['host'] != pair['host']:
							keep.append( pair )
				keep.extend( request['pairs'] )
				self.hostfile.writeDetours( keep )
				response['response'] = 'set'
				response['pairs'] = request['pairs']
			elif request['method'] == 'delete':
				pairs = self.hostfile.getDetours()
				keep = []
				for pair in pairs:
					if pair['host'] not in request['hosts']:
						keep.append( pair )
				self.hostfile.writeDetours( keep )
				response['response'] = 'deleted'
				response['hosts'] = request['hosts']
			else:
				response['response'] = 'invalid'

			self.push( json.dumps( response ) )

			self.close_when_done()

class DetourServer ( asyncore.dispatcher ):

	def __init__( self, port, hf ):
		asyncore.dispatcher.__init__(self)
		self.create_socket( socket.AF_INET, socket.SOCK_STREAM )
		self.bind( ( '127.0.0.1', port ) )
		self.listen( 5 )
		self.hostfile = hf

	def handle_accept ( self ):
		conn, addr = self.accept()
		DetourChannel( self, conn, addr, self.hostfile )

hf = hostfile.HostFile( config.get( 'Server', 'hostfile' ) )
if not hf.canWrite():
	print "Can't access hosts file: %s" % config.get( 'Server', 'hostfile' )
	exit()
s = DetourServer( config.getint( 'Server', 'port' ), hf )

# TODO: Daemonize
print "Serving at port", config.getint( 'Server', 'port' ), "..."
try:
	asyncore.loop()
except Exception, e:
	print "Shutting Down!"
	asyncore.socket_map.clear()

